---
title: "Session 5 lab exercise: loglinear regression part 2"
author: "Levi Waldron"
institute: "CUNY SPH Biostatistics 2"
clean: false
output:
  html_document:
    toc: yes
    df_print: paged
    theme: lumen
    number_sections: yes
  md_document:
    preserve_yaml: false
always_allow_html: true
---

# Learning objectives {-}

1. Fit Poisson, NB, and zero-inflated loglinear models
2. Perform nested deviance test for model selection
3. Make diagnostic plots of loglinear models


# Load the needle-sharing dataset

```{r loadandfilter, message=FALSE}
suppressPackageStartupMessages({
  library(tidyverse)
})
needledat <- readr::read_csv("needle_sharing.csv")
needledat2 <- needledat %>%
  dplyr::filter(sex %in% c("M", "F") &
                  ethn %in% c("White", "AA", "Hispanic") &
                  !is.na(homeless)) %>%
  mutate(
    homeless = recode(homeless, "0" = "no", "1" = "yes"),
    hiv = recode(
      hivstat,
      "0" = "negative",
      "1" = "positive",
      "2" = "yes"
    )
  )
```

# Compare the mean to the variance of the outcome variable. Calculate what fraction of the counts are zero.

```{r}
meanvarzeros <- needledat2 %>% 
  filter(complete.cases(shared_syr)) %>%
summarise(
  mean = mean(shared_syr),
  var = var(shared_syr),
  fraczero = (sum(shared_syr == 0) / length(shared_syr))
)
meanvarzeros
```

The mean number of needle sharing events per participant is `r signif(pull(meanvarzeros, mean), 3)`, the variance is `r signif(pull(meanvarzeros, var), 3)`, and the fraction of participants who never shared a needle is `r signif(pull(meanvarzeros, fraczero), 3)`. (Note how I put computed results in the text here rather than writing in numbers manually - they will change automatically if the analysis is changed!)

# Create a histogram of the outcome variable.

This was done in the lecture using base R, but let's do it here with ggplot2. Note the filtering of complete cases only is unnecessary because ggplot does it anyways, but this gets rid of a warning (try it without filtering). Specifying the binwidth is also unnecessary, but by default geom_histogram creates histogram bins of size 2 (ie 0 and 1 in the same bin, 2 and 3 together, ...)

```{r}
library(ggplot2)
filter(needledat2, complete.cases(shared_syr)) %>%
  ggplot(aes(x = shared_syr)) +
  geom_histogram(binwidth = 1)
```


# Fit Poisson and Negative Binomial models as in the lecture, with and without zero inflation.

## Poisson

```{r}
fit.pois <- glm(shared_syr ~ sex + ethn + homeless,
                data = needledat2,
                family = poisson(link = "log"))
```

## Negative Binomial

```{r}
library(MASS)
fit.negbin <- MASS::glm.nb(shared_syr ~ sex + ethn + homeless,
                           data = needledat2)
```

## Zero-inflated Poisson

```{r}
library(pscl)
fit.ZIpois <- pscl::zeroinfl(shared_syr ~ sex + ethn + homeless | 1,
                       dist = "poisson",
                       data = needledat2)
```

## Intercept-only ZI model

```{r}
fit.ZInegbin <-
  pscl::zeroinfl(shared_syr ~ sex + ethn + homeless | 1,
           dist = "negbin",
           data = needledat2)
```

# Use chi-square nested deviance tests to assess which model seems to fit best.

I want to calculate the log-likelihood from each model. The simplest way is to call the `logLik` function one at a time:

```{r}
logLik(fit.pois)
logLik(fit.negbin)
logLik(fit.ZIpois)
logLik(fit.ZInegbin)
```

Just to demonstrate a fancier way that could be used on many models, I'll create a list of model objects:
```{r}
listofmodels <- list(
  poisson = fit.pois,
  negbin = fit.negbin,
  ZIpois = fit.ZIpois,
  ZInegbin = fit.ZInegbin
)
```

Then demonstrate how the `lapply` (also related functions like `sapply`) can be used to implicitly loop over elements of a list, to do exactly the same thing:
```{r}
lapply(listofmodels, logLik)
```

OK now to actually answer the question. Just to get an idea of how big a difference in $-2 \times log(likelihood)$ would be statistically significant on one difference of degrees of freedom:

```{r}
qchisq(p=0.95, df = 1)  #critical value is 3.84
qchisq(p=0.05, df = 1, lower.tail = FALSE) #equivalent
```

Or two degrees of freedom:
```{r}
qchisq(p=0.95, df = 2)  #critical value is 6
```

All the differences in double log-likelihoods above are _much_ larger (in the hundreds) than these critical significance values, except for the difference between Negative Binomial and zero-inflated negative binomial models. So it doesn't look like zero inflation helped the Negative Binomial distribution model, but it helped the Poisson model, and the Negative Binomial model fits better than the Poisson model.

# Create residual deviance plots using the functions defined in the lecture.

These were the (base graphics) functions defined to create the first two panels of residuals plots for all of these types of models.
```{r}
plotpanel1 <- function(fit, ...) {
  plot(
    x = predict(fit),
    y = residuals(fit, type = "pearson"),
    xlab = "Predicted Values",
    ylab = "Pearson Residuals",
    ...
  )
  abline(h = 0, lty = 3)
  lines(lowess(x = predict(fit), y = resid(fit, type = "pearson")),
        col = "red")
}
plotpanel2 <- function(fit, ...) {
  resids <- scale(residuals(fit, type = "pearson"))
  qqnorm(resids, ylab = "Std Pearson resid.", ...)
  qqline(resids)
}
```

Let's make these plots. As a shortcut, remember that list of models? I'm going to use an explicit `for` loop this time instead of `lapply` so that I can use the vector names as plot titles.

Although we saw some evidence from the chi-square test that the Negative Binomial distribution fit better than the Poisson distribution (not surprising since these data are very over-dispersed), these diagnostic plots show the Negative Binomial distribution still does not fit well at all. I would take any interpretation of the coefficients of these models with plenty of skepticism. But this dataset is tricky and I'm not sure offhand of a good model to fit it.

Note, the line `par(mfrow=c(1, 2))` only works for base graphics (not ggplot2), and creates a 1 row by 2 column plot panel. 

```{r}
par(mfrow=c(1, 2))
for (i in seq_along(listofmodels)){
  plotpanel1(listofmodels[[i]], main = names(listofmodels)[i])
  plotpanel2(listofmodels[[i]], main = names(listofmodels)[i])
}
```

# Plot predicted vs observed counts

```{r}
preds <- data.frame(observed = na.omit(pull(needledat2, shared_syr)),
           lm = predict(fit.lm),
           poisson = predict(fit.pois),
           negbin = predict(fit.negbin),
           ZIpois = predict(fit.ZIpois),
           ZInegbin = predict(fit.ZInegbin))
```

